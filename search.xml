<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二维数组的查找</title>
      <link href="/2020/11/19/er-wei-shu-zu-de-cha-zhao/"/>
      <url>/2020/11/19/er-wei-shu-zu-de-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>现有矩阵 matrix 如下：</p><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p><p>给定 target = 20，返回 false。</p><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/" target="_blank" rel="noopener">leetcode传送门</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><ul><li>在做这个题的时候，如果你要暴力的话，直接对数组进行搜索，那样的你就没有利用完题目所给你的条件，这显然是不及格的做法</li><li>所以我们需要在对题目所给条件完全利用的情况下，去尽可能的减少时间和空间的使用</li><li>然后我就想使用一个深度优先搜索来去做这个题</li></ul><h2 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h2><pre><code> bool find(int row,int cur,int target,vector&lt;vector&lt;int&gt;&gt;&amp; matrix){        //如果查找的数超过了边界,直接返回false        if(row==matrix.size() || cur==matrix[row].size()) return false;        //如果能够找到当前的数，那么返回true        if(matrix[row][cur]==target) return true;        //如果当前的数比目标值大，那么返回false，结束该点的向下查找        if(matrix[row][cur]&gt;target) return false;        //如果当前的数比目标值小，那么就向左和向下查        if(matrix[row][cur]&lt;target){            //cout&lt;&lt;row&lt;&lt;endl;            //这一步我觉得很不错            return (find(row+1,cur,target,matrix) || find(row,cur+1,target,matrix));        }        //cout&lt;&lt;row&lt;&lt;endl;        return false;    }    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {        int row=0;        int cur=0;        return find(row,cur,target,matrix);    }</code></pre><ul><li>是不是觉得很长，而且关键还是超时了，这也是个不合格的题解，<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://img-blog.csdnimg.cn/20201119142506668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FfU01BS0VfQQ==,size_16,color_FFFFFF,t_70#pic_center" alt="超时情况"></li><li>关键还是只是几个用例没有过，这就很难受了，无奈点开题解，果然大佬就在里面，看了他们的方法重新写了一下</li><li>Code<pre><code>bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {      int i = matrix.size() - 1, j = 0;      //从左下角（右上角也行）开始搜索，因为这个两个地点刚好满足一边比该点小一边比该点大      while(i &gt;= 0 &amp;&amp; j &lt; matrix[0].size())      {          //如果当前点比目标值大，那么向上移动一行          if(matrix[i][j] &gt; target) i--;          //如果小的话就向右移动一列          else if(matrix[i][j] &lt; target) j++;          //相等就返回true          else return true;      }      //如果查完整个路径都没有的话，返回false      return false;  }</code></pre></li><li>是不是感觉比之前那个好太多了，这完全是暴打我的想法</li><li>其实这个思想就是利用了在左下角和右上角那个点的特殊性，再看一次这个数组的情况：<br>[<br>[1,   4,  7, 11, 15],<br>[2,   5,  8, 12, 19],<br>[3,   6,  9, 16, 22],<br>[10, 13, 14, 17, 24],<br>[18, 21, 23, 26, 30]<br>]<br>我们可以看到左下角和右上角的这两个点的相邻点是一个比它小，一个比它大，这就比我从左上角开始搜索又多了一个可以用的条件，让题目更简单</li></ul><h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><pre><code>不得不说，就是遇题的get的点不一样，写出的代码就是不也一样，一个简单到几行代码就能AC，另一个又多，而且还是在最后超时，所以这就是思路的问题，完美利用题中所给条件。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 题解 剑指offer </category>
          
          <category> 做题经验get </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome页面被百度劫持</title>
      <link href="/2020/11/19/chrome-bei-bai-du-jie-chi/"/>
      <url>/2020/11/19/chrome-bei-bai-du-jie-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>在使用Chrome浏览器打开后直接弹出一个百度的界面</li><li><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://img-blog.csdnimg.cn/20201119223210578.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FfU01BS0VfQQ==,size_16,color_FFFFFF,t_70#pic_center" alt="百度界面"></li><li>这看着就很烦啊，我就想能不能把这个改回来，但改设置里的东西明显没有什么用，试了好多方法还是没什么用</li></ul><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ul><li><p>首先找到这个路径，把chrome随便改个名字就行</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://img-blog.csdnimg.cn/20201119223442843.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FfU01BS0VfQQ==,size_16,color_FFFFFF,t_70#pic_center" alt="重命名"></p></li><li><p>然后问题就解决了</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://img-blog.csdnimg.cn/20201119223609897.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FfU01BS0VfQQ==,size_16,color_FFFFFF,t_70#pic_center" alt="解决后"></p></li><li><p>不得不说，这种劫持还是很恶心，还是要保持良好的上网习惯</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 解决方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客主页</title>
      <link href="/2020/10/30/zhu-ye/"/>
      <url>/2020/10/30/zhu-ye/</url>
      
        <content type="html"><![CDATA[<h1 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h1><pre><code>记录自己在LeetCode做题过程中的心得和感受，以及对LeetCode解题的具体题解和思路，同时也把自己学习知识的总结和学习过程记录下来。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求根到叶子节点的数字之和</title>
      <link href="/2020/10/29/qiu-gen-dao-xie-zi-jie-dian/"/>
      <url>/2020/10/29/qiu-gen-dao-xie-zi-jie-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">传送门</a></p><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="思路来源"><a href="#思路来源" class="headerlink" title="思路来源"></a>思路来源</h2><ul><li>对一个树进行前序遍历的方法，可以递归也可以迭代，我这里是用递归的方式写的，习惯了。</li><li>那么这个题和前序遍历有什么关系？像[1,2,3]这样的树，最后和为25（12+13），我们注意这个结果的来源是1—&gt;2（12）,然后1—&gt;3（13）,这是不是和前序很像，但还是有区别，我们需要保留有右节点的当前节点，否则就会变成12+3，这样的结果。</li></ul><h2 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h2><ul><li><p>首先我们需要一个数来记录最后所有的和 <code>int ans</code>。</p></li><li><p>还需要一个数组来储存节点到叶子节点代表的所有数字 <code>vector&lt;int&gt; res</code>。</p></li><li><p>当然还有一个数来记录从节点到叶子节点的代表数字 <code>int temp</code>。</p></li><li><p>实现的过程和前序遍历一样，在递归的过程中判断当前的节点是否为叶子节点，如果是，那么将叶子节点的值加到<code>temp</code>中，并将<code>temp</code>的值存进<code>res</code>数组中，然后将叶子节点的值取出，更新<code>temp</code>。</p><pre><code>if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr){          //把叶子节点的值加进temp里          temp=temp*10+root-&gt;val;          //cout&lt;&lt;temp&lt;&lt;endl;          //将值传进res数组中          res.push_back(temp);          //将叶子节点的值取出          temp=(temp-(root-&gt;val))/10;          return;      }</code></pre></li><li><p>如果当前值不是叶子节点，将当前值加入temp，然后判断它的左节点是否为空，如果不为空，继续向左遍历，在遇到叶子节点后，如果当前节点没有右节点 if(root-&gt;right==nullptr) 就开始更新 temp 的值，因为这一条分支的值已经记录了，所以我们需要去找节点的来一条分支，如果我们遇到当前的节点还存在右节点的话，那么我们这个节点就先保留，去记录右节点分支的值。</p><pre><code>//如果不是叶子节点，更新temp的值      temp=temp*10+root-&gt;val;      //如果它的左节点不为空      if(root-&gt;left!=nullptr){          //向左遍历          DFS(root-&gt;left);          //如果它的右节点有值的话，就先不取出这个节点的值，没有就取出          if(root-&gt;right==nullptr){              temp=(temp-(root-&gt;val))/10;          }      }</code></pre></li><li><p>如果没有左节点，有右节点的话，就向右遍历，在遇到叶子节点后，就开始向上退。</p><pre><code>if(root-&gt;right!=nullptr){          //向右遍历          DFS(root-&gt;right);          //取出右节点的值          temp=(temp-(root-&gt;val))/10;      }</code></pre></li></ul><h1 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h1><pre><code>/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    void DFS(TreeNode* root){        //如果这个节点是叶子节点        if(root-&gt;left==nullptr &amp;&amp; root-&gt;right==nullptr){            //把叶子节点的值加进temp里            temp=temp*10+root-&gt;val;            //cout&lt;&lt;temp&lt;&lt;endl;            //将值传进res数组中            res.push_back(temp);            //将叶子节点的值取出            temp=(temp-(root-&gt;val))/10;            return;        }        //如果不是叶子节点，更新temp的值        temp=temp*10+root-&gt;val;        //如果它的左节点不为空        if(root-&gt;left!=nullptr){            //向左遍历            DFS(root-&gt;left);            //如果它的右节点有值的话，就先不取出这个节点的值，没有就取出            if(root-&gt;right==nullptr){                temp=(temp-(root-&gt;val))/10;            }        }        //如果它的左节点为空，而右节点不为空        if(root-&gt;right!=nullptr){            //向右遍历            DFS(root-&gt;right);            //取出右节点的值            temp=(temp-(root-&gt;val))/10;        }    }    int sumNumbers(TreeNode* root) {        if(!root) return 0; //如果节点为空，返回0        //对这棵树进行前序遍历        DFS(root);        //把节点到叶子节点代表的数的值相加        for(int i=0;i&lt;res.size();i++){            ans+=res[i];        }        //返回最终的答案        return ans;    }private:    int ans=0;//返回最后的和    vector&lt;int&gt; res;//记录节点到叶子节点的代表的数字    int temp=0;//临时记录分支里的数字};</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 题解 深度优先遍历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>长按输入</title>
      <link href="/2020/10/21/chang-an-shu-ru/"/>
      <url>/2020/10/21/chang-an-shu-ru/</url>
      
        <content type="html"><![CDATA[<h1 id="题目介绍："><a href="#题目介绍：" class="headerlink" title="题目介绍："></a>题目介绍：</h1><p>传送门：<a href="https://leetcode-cn.com/problems/long-pressed-name/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/long-pressed-name/</a></p><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>使用双指针，对两个数组进行实时比较，一次循环就能AC，这里说说循环里面需要注意的细节，while循环里这个代码<code>if(typed[tem2]==name[tem1])</code>一定要在<code>if(tem2&gt;0 &amp;&amp; typed[tem2]==typed[tem2-1])</code>这个前面，不仅是因为<code>tem2&gt;0</code>，因为你也可以这样写</p><pre><code>if(tem2&gt;0){    if(typed[tem2]==typed[tem2-1]) tem2++;    else if(typed[tem2]==name[tem1]){        tem1++;        tem2++;    }else return false;}</code></pre><p>但这样写就会导致一个问题，它会去先判断typed的当前字符是否和前一个相同，然后一直tem2++,因为我当时就这样写的，就发现它结束后的值不太正常，就是这个问题导致的。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://img-blog.csdnimg.cn/20201021183712711.jpeg#pic_center" alt="在这里插入图片描述"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Solution {public:    bool isLongPressedName(string name, string typed) {        int tem1=0; //name的指针        int tem2=0; //typed的指针        //对两个数组进行比较        while(tem2&lt;typed.size()){            //如果两个字符相同，就同时向后移            if(typed[tem2]==name[tem1]){                tem1++;                tem2++;            }else if(tem2&gt;0 &amp;&amp; typed[tem2]==typed[tem2-1]) tem2++; //如果name和typed不相同，看typed是否和之前一样，如果一样就移动它            //否则就返回false            else return false;        }        //最后判断name里的字符是否判断完了        return tem1==name.size();    }};</code></pre><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="失败的栈处理"><a href="#失败的栈处理" class="headerlink" title="失败的栈处理"></a>失败的栈处理</h2><p>这个我本来想用栈做的，因为之前做过一个比较含退格字符的题目,传送门<a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/backspace-string-compare/</a>，我就想这个题应该和那个题也差不多（还是太年轻了）。这个题和那个题差别就在如果在typed的里去通过当前字符和前一个字符是否相同来删除的话，那么如果name本来就是存在重复的字符这个情况就不能处理，所以这是一个失败的栈处理。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code>    stack&lt;char&gt; temp;    for(int i=0;i&lt;typed.size();i++){        if(temp.empty()) temp.push(typed[i]);        else if(typed[i]!=temp.top()) temp.push(typed[i]);        else continue;    }    int Num=name.size()-1;    while(!temp.empty() &amp;&amp; Num&gt;=0)    {        if(temp.top()==name[Num]){            temp.pop();            Num--;        }else return false;    }    if(Num&lt;0) return true;    else return false;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 题解 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重排链表</title>
      <link href="/2020/10/20/chong-pai-lian-biao/"/>
      <url>/2020/10/20/chong-pai-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>传送门：<a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reorder-list/</a></p><hr><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>class Solution {public:    //利用快慢指针来查找链表的中间节点    ListNode* MID(ListNode* head){        //快指针比慢指针永远快一步        ListNode* fast=head;        ListNode* slow=head;        //当快指针走到末尾时，慢指针则刚好走了一半        while(fast!=nullptr &amp;&amp; fast-&gt;next!=nullptr){            fast=fast-&gt;next-&gt;next;            slow=slow-&gt;next;        }        //返回慢指针        return slow;    }    //对链表进行反转    ListNode* REVERSE(ListNode* head){        ListNode *pre; //记录前一个节点        ListNode *cur; //记录当前节点        ListNode *next; //记录下一个节点        cur=head;        pre=NULL;        while(cur!=NULL)        {            next=cur-&gt;next; //保存cur的下一个节点            cur-&gt;next=pre; //令当前节点指向前一个节点            pre=cur; //更新pre的值            cur=next; //当前节点向后移一位        }        return pre; //pre此时已经到最后一个节点，也就是反转后的头节点    }    void reorderList(ListNode* head) {        if(!head) return;        ListNode* mid=MID(head); //获取中间节点        //cout&lt;&lt;mid-&gt;val;        //通过中间节点，分为右链表和左链表        ListNode* left=head;         ListNode* right=mid-&gt;next;        mid-&gt;next=nullptr; //断开链表，分为左右链表        //对右边链表进行反转        right=REVERSE(right);        //cout&lt;&lt;right-&gt;next-&gt;val;        //将左链表和反转后的右链表合并        ListNode* L_temp; //保存left当前节点的下一个节点        ListNode* R_temp; //保存right当前节点的下一个节点        //将两个链表进行合并        while(left-&gt;next!=nullptr &amp;&amp; right!=nullptr){            L_temp=left-&gt;next;//保存下一个节点            R_temp=right-&gt;next;//保存下一个节点            //连个链表进行相连            left-&gt;next=right;             right-&gt;next=L_temp;            //更新left和right节点的位置            left=L_temp;            right=R_temp;        }    }};</code></pre><hr><h1 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h1><p>在做这个题的时候，一开始想使用双指针的思想，但很快就否定了，因为链表不能从后向前，这个就直接out。这个不行就找其他方法，看了几遍题，就想先去找到这个链表的中点，然后将右边的链表倒置，再重新连接起来，要是不会找链表的中点和对链表进行转置，可以去看这两个题链表的中间节点：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a>和反转链表<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/</a>。</p><hr><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>在把代码写出来后，在提交的时候发现竟然会出现执行错误，但却不出现报错，这就难受了，这样的执行错误连改bug的机会都不给，这样多半是和逻辑没什么关系，看看是不是出现溢出或者什么错误操作，然后我就发现了关键的代码 <code>mid-&gt;next=nullptr;</code> 。要是不添加这个代码的话，就会导致左右链表没有断开，然后出现环的情况。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 题解 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
